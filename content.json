{"meta":{"title":"葛鹏程|blog","subtitle":null,"description":"葛鹏程的博客，web前端开发，h5，javascript，JavaScript","author":"葛鹏程","url":"http://aventador.top"},"pages":[{"title":"about","date":"2019-02-01T07:29:25.000Z","updated":"2019-02-01T07:30:24.850Z","comments":true,"path":"about/index.html","permalink":"http://aventador.top/about/index.html","excerpt":"","text":"关于我"}],"posts":[{"title":"webpack4系列教程（九）：开发环境和生产环境","slug":"webpack4系列教程（九）：开发环境和生产环境","date":"2019-02-02T13:26:25.000Z","updated":"2019-02-02T13:26:55.955Z","comments":true,"path":"posts/8d0369c8.html","link":"","permalink":"http://aventador.top/posts/8d0369c8.html","excerpt":"","text":"1. 构建开发环境如果你一直跟随我前面的博文，那么你对webpack的基础知识已经有比较深刻的理解了。之前，我们一直执行着：1npm run build 来打包编译输出我们的代码，本文我们来看看如何构建一个开发环境，来使我们的开发变得方便些。 1.1 webpack-dev-serverwebpack-dev-server是一个简单的小型的web服务器，并且能够实时重载，配置也很简单，首先安装：1npm install --save-dev webpack-dev-server 配置webpack.config.js:1234567devServer: &#123; port: 8080, // 端口号 host: '0.0.0.0', // 主机名，设为该值可通过IP访问 overlay: &#123; errors: true // 错误提示 &#125; &#125; 在package.json中添加命令：1\"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config config/webpack.config.js\" 执行：1npm run dev 可见我们的服务已经跑起来了： 1.2 source-map在webpack打包源码时，我们会很难找到错误的出现位置，比如将源文件 sum.js、minus.js打包到bundle.js中，其中一个源文件出现了错误，仅仅会追踪到bundle.js中，这对我们来说并不理想。因此为了更加便捷的找到错误的原始位置，JavaScript为我们提供了 source-map的功能，将编译后的代码映射回原始源代码。如果一个错误来自于 sum.js，source map 就会明确的告诉你。 我们来测试一下，在sum.js中输出一个错误：12345// ES Mudule 规范export default function (a, b) &#123; console.error('this is test') // 输出错误 return a + b&#125; 在没有devtool配置的情况下 npm run dev，会发现错误提示的行数并不准确， 原因是我们的代码是被编译过的 然后在webpack.config.js中加入配置：1devtool: 'inline-source-map', // 加入devtool配置 当配置文件改动时需要重新执行 npm run dev： 错误提示行数以及源码映射都是正确的。devtool的取值有很多，大家可根据需要自行配置 1.3 模块热替换 模块热替换(Hot Module Replacement)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。 使用非常简单，在webpack.config.js中引入webpack:1const webpack = require('webpack') 在plugins数组中添加：12new webpack.NamedModulesPlugin(),new webpack.HotModuleReplacementPlugin() 给devServer中的hot属性设为true：12345678devServer: &#123; port: 8080, // 端口号 host: '0.0.0.0', // 主机名，设为该值可通过IP访问 overlay: &#123; errors: true // 错误提示 &#125;, hot: true &#125; 这样我们修改代码的时候就可以局部刷新模块而不是刷新整个页面了。 2.构建生产环境 开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置。 虽然，以上我们将生产环境和开发环境做了略微区分，但是，请注意，我们还是会遵循不重复原则(Don’t repeat yourself - DRY)，保留一个“通用”配置。为了将这些配置合并在一起，我们将使用一个名为 webpack-merge 的工具。通过“通用”配置，我们不必在环境特定的配置中重复代码。 我们先从安装 webpack-merge 开始，用来合并webpack配置项：1npm install --save-dev webpack-merge 在config文件夹下创建 webpack.dev.js 和 webpack.build.js 并修改 webpack.config.js，将开发与生产环境的公共配置放在webpack.config.js中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const isDev = process.env.NODE_ENV === 'development'const config = &#123; entry: &#123; main: path.join(__dirname, '../src/main.js') &#125;, output: &#123; filename: '[name].bundle.js', path: path.join(__dirname, '../dist') &#125;, module: &#123; rules: [ &#123; test: /\\.(vue|js|jsx)$/, loader: 'eslint-loader', exclude: /node_modules/, enforce: 'pre' &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.vue$/, loader: 'vue-loader', options: createVueLoaderOptions(isDev) &#125;, &#123; test: /\\.ejs$/, use: ['ejs-loader'] &#125;, &#123; test: /\\.css$/, use: [ isDev ? 'vue-style-loader' : MiniCssExtractPlugin.loader, &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, 'postcss-loader' ] &#125;, &#123; test: /\\.less$/, use: [ isDev ? 'vue-style-loader' : MiniCssExtractPlugin.loader, 'css-loader', &#123; loader: 'postcss-loader', options: &#123; sourceMap: true &#125; &#125;, 'less-loader' ] &#125;, &#123; test: /\\.(jpg|jpeg|png|gif|svg)$/, use: [ &#123; loader: 'url-loader', options: &#123; name: '[path][name]-[hash:5].[ext]', limit: 1024 &#125; &#125; ] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, '../index.html'), inject: true, minify: &#123; removeComments: true &#125; &#125;) ]&#125;module.exports = config webpack.dev.js1234567891011121314151617const merge = require('webpack-merge')const common = require('./webpack.config.js')module.exports = merge(common, &#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; port: 8080, host: '0.0.0.0', overlay: &#123; errors: true &#125;, historyApiFallback: &#123; index: '/index.html' &#125; &#125;&#125;) webpack.build.js1234567891011121314151617181920212223242526272829303132333435363738394041const path = require('path')const CleanWebpackPlugin = require('clean-webpack-plugin')const MiniCssExtractPlugin = require('mini-css-extract-plugin')const merge = require('webpack-merge')const common = require('./webpack.config.js')module.exports = merge(common, &#123; mode: 'production', optimization: &#123; splitChunks: &#123; chunks: 'initial', automaticNameDelimiter: '.', cacheGroups: &#123; commons: &#123; name: 'commons', chunks: 'initial', minChunks: 2, priority: 3 &#125;, vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: 1 &#125; &#125; &#125;, runtimeChunk: &#123; name: entrypoint =&gt; `manifest.$&#123;entrypoint.name&#125;` &#125; &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].css' &#125;), new CleanWebpackPlugin( ['dist'], &#123; root: path.join(__dirname, '../') &#125; ) ]&#125;) 修改package.json的命令：12\"dev\": \"cross-env NODE_ENV=development webpack-dev-server --config config/webpack.dev.js\",\"build\": \"cross-env NODE_ENV=production webpack --config config/webpack.build.js --progress --inline --colors\" 现在分别执行 npm run dev 和 npm run build 就会得到你想要的了。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（八）：使用Eslint审查代码","slug":"webpack4系列教程（八）：使用Eslint审查代码","date":"2019-02-02T13:25:18.000Z","updated":"2019-02-02T13:26:10.340Z","comments":true,"path":"posts/46ef4800.html","link":"","permalink":"http://aventador.top/posts/46ef4800.html","excerpt":"","text":"前言：本章内容，我们在项目中加入eslint配置，来审查校验代码，这样能够避免一些比较低级的错误。并且在团队协作的时候，保持同一种风格和规范能提高代码的可读性，进而提高我们的工作效率。 安装：eslint-config-standard 是一种较为成熟通用的代码审查规则，这样就不用我们自己去定义规则了，使用起来非常方便，记住还需要安装一些依赖插件：1npm install --save-dev eslint eslint-config-standard eslint-plugin-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node 配置：在项目根目录下创建 .eslintrc 文件：123456&#123; \"extends\": \"standard\", \"rules\": &#123; \"no-new\": \"off\" &#125;&#125; 在vue项目中，.vue文件中的 script标签内的代码，eslint 是无法识别的，这时就需要使用插件： eslint-plugin-html1npm i eslint-plugin-html -D 然后在 .eslintrc 中配置该插件：123456789&#123; \"extends\": \"standard\", \"plugins\": [ \"html\" ], \"rules\": &#123; \"no-new\": \"off\" &#125;&#125; 这样就能解析 .vue文件中的JS代码了，官方也是如此推荐。 使用：配置完成，如何使用呢？在 package.json 文件中添加一条 script：1234\"scripts\": &#123; \"build\": \"cross-env NODE_ENV=production webpack --config config/webpack.config.js --progress --inline --colors\", \"lint\": \"eslint --ext .js --ext .vue src/\" &#125; - -ext 代表需要解析的文件格式，最后接上文件路径，由于我们的主要代码都在src 目录下，这里就配置 src 文件夹。 1npm run lint 可见控制台给出了很多错误： 在项目前期没有加入eslint的情况下，后期加入必然会审查出许多错误。出现这么多错误之后，如果我们逐条手动去解决会非常耗时，此时可以借助eslint自动修复，方法也很简单。 只需要添加一条命令即可： 12345\"scripts\": &#123; \"build\": \"cross-env NODE_ENV=production webpack --config config/webpack.config.js --progress --inline --colors\", \"lint\": \"eslint --ext .js --ext .vue src/\", \"lint-fix\": \"eslint --fix --ext .js --ext .jsx --ext .vue src/\"&#125; 然后执行 1npm run lint-fix 我们希望在开发过程中能够实时进行eslint代码审查，需要安装两个依赖：1npm i eslint-loader babel-eslint -D 修改 .eslintrc：123456789101112&#123; \"extends\": \"standard\", \"plugins\": [ \"html\" ], \"rules\": &#123; \"no-new\": \"off\" &#125;, \"parserOptions\":&#123; \"parser\": \"babel-eslint\" &#125;&#125; 由于我们的项目使用了webpack并且代码都是经过Babel编译的，但是Babel处理过的代码有些语法可能对于eslint支持性不好，所以需要指定一个 parser。下一步，在webpack.config.js中添加loader：123456&#123; test: /\\.(vue|js)$/, loader: 'eslint-loader', exclude: /node_modules/, enforce: 'pre' &#125; enforce: ‘pre’ 表示预处理，因为我们只是希望eslint来审查我们的代码，并不是去改变它，在真正的loader(比如：vue-loader)发挥作用前用eslint去检查代码。 记得在你的IDE中安装并开启eslint插件功能，这样就会有错误提示了。 比如： 图中的错误是未使用的变量。 editorconfig: editorconfig是用来规范我们的IDE配置的，在根目录创建 .editorconfig文件：123456789root = true[*]charset = utf-8indent_style = spaceindent_size = 2end_of_line = lfinsert_final_newline = truetrim_trailing_whitespace = true 这样就能在各种IDE使用相同的配置了。 同样需要在IDE中安装editorconfig插件 以上就是eslint的配置方法了。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（七）：使用 babel-loader","slug":"webpack4系列教程（七）：使用-babel-loader","date":"2019-02-02T13:24:32.000Z","updated":"2019-02-02T13:25:01.444Z","comments":true,"path":"posts/78d52b07.html","link":"","permalink":"http://aventador.top/posts/78d52b07.html","excerpt":"","text":"1. 什么是Babel如今 ES6 语法在开发中已经非常普及，甚至也有许多开发人员用上了 ES7 或 ES8 语法。然而，浏览器对这些高级语法的支持性并不是非常好。因此为了让我们的新语法能在浏览器中都能顺利运行，Babel 应运而生。Babel是一个JavaScript编译器，能够让我们放心的使用新一代JS语法。比如我们的箭头函数：1() =&gt; console.log('hello babel') 经过Babel编译之后：123(function()&#123; return console.log('hello babel');&#125;); 会编译成浏览器可识别的ES5语法。 2. 在webpack中使用babel-loader安装：1npm install -D babel-loader @babel/core @babel/preset-env webpack 修改 webpack.config.js，加入新的loader：12345&#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/&#125; 遇到JS文件就先用babel-loader处理，exclude表示排除 node_modules 文件夹中的文件。loader的配置就OK了，可是这样还不能发挥Babel的作用。在项目根目录下创建一个 .babelrc 文件，添加代码：12345&#123; \"presets\": [ \"@babel/preset-env\" ]&#125; 我们还希望能够在项目对一些组件进行懒加载，所以还需要一个Babel插件：1npm i babel-plugin-syntax-dynamic-import -D 在 .babelrc 文件中加入plugins配置：12345678&#123; \"presets\": [ \"@babel/preset-env\" ], \"plugins\": [ \"syntax-dynamic-import\" ]&#125; 在src 目录下创建 helper.js：1console.log('this is helper') 再来修改我们的 main.js ：12345678910111213141516171819202122232425import 'babel-polyfill'import Modal from './components/modal/modal'import './assets/style/common.less'import _ from 'lodash'const App = function () &#123; let div = document.createElement('div') div.setAttribute('id', 'app') document.body.appendChild(div) let dom = document.getElementById('app') let modal = new Modal() dom.innerHTML = modal.template(&#123; title: '标题', content: '内容', footer: '底部' &#125;) let button = document.createElement('button') button.innerText = 'click me' button.onclick = () =&gt; &#123; const help = () =&gt; import('./helper') help() &#125; document.body.appendChild(button)&#125;const app = new App()console.log(_.camelCase('Foo Bar')) 当button点击时，加载 helper 然后调用。打包之后可见：多了一个 3.bundle.js，在浏览器打开 dist/index.html ，打开 network查看，3.bundle.js并未加载：当点击button之后，发现浏览器请求了3.bundle.js，控制台也打印出了数据。 由于 Babel 只转换语法(如箭头函数)， 你可以使用 babel-polyfill 支持新的全局变量，例如 Promise 、新的原生方法如 String.padStart (left-pad) 等。 安装：1npm install --save-dev babel-polyfill 在入口文件引入就可以了：1import 'babel-polyfill'","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（六）：使用SplitChunksPlugin分割代码","slug":"webpack4系列教程（六）：使用SplitChunksPlugin分割代码","date":"2019-02-02T13:23:50.000Z","updated":"2019-02-02T13:24:17.481Z","comments":true,"path":"posts/2040befe.html","link":"","permalink":"http://aventador.top/posts/2040befe.html","excerpt":"","text":"1. SplitChunksPlugin的概念起初，chunks(代码块)和导入他们中的模块通过webpack内部的父子关系图连接.在webpack3中，通过CommonsChunkPlugin来避免他们之间的依赖重复。而在webpack4中CommonsChunkPlugin被移除，取而代之的是 optimization.splitChunks 和 optimization.runtimeChunk 配置项，下面展示它们将如何工作。 在默认情况下，SplitChunksPlugin 仅仅影响按需加载的代码块，因为更改初始块会影响HTML文件应包含的脚本标记以运行项目。 webpack将根据以下条件自动拆分代码块： 会被共享的代码块或者 node_mudules 文件夹中的代码块 体积大于30KB的代码块（在gz压缩前） 按需加载代码块时的并行请求数量不超过5个 加载初始页面时的并行请求数量不超过3个 举例1：1234// index.js// 动态加载 a.jsimport(&apos;./a&apos;) 1234// a.jsimport &apos;vue&apos;// ... 打包之后的结果会创建一个包含 vue 的独立代码块，当包含 a.js 的原始代码块被调用时，这个独立代码块会并行请求进来。 原因： vue 来自 node_modules 文件夹 vue 体积超过30KB 导入调用时的并行请求数为2 不影响页面初始加载 我们这样做的原因是因为，vue代码并不像你的业务代码那样经常变动，把它单独提取出来就可以和你的业务代码分开缓存，极大的提高效率。 举例2：1234// entry.jsimport(&quot;./a&quot;);import(&quot;./b&quot;); 1234// a.jsimport &quot;./helpers&quot;; // helpers is 40kb in size// ... 12345// b.jsimport &quot;./helpers&quot;;import &quot;./more-helpers&quot;; // more-helpers is also 40kb in size// ... 结果：将创建一个单独的块，其中包含./helpers它的所有依赖项。在导入调用时，此块与原始块并行加载。 原因： 条件1：helpers 是共享块 条件2：helpers大于30kb 条件3：导入调用的并行请求数为2 条件4：不影响初始页面加载时的请求 2. SplitChunksPlugin的默认配置以下是SplitChunksPlugin的默认配置： 1234567891011121314151617181920splitChunks: &#123; chunks: &quot;async&quot;, minSize: 30000, // 模块的最小体积 minChunks: 1, // 模块的最小被引用次数 maxAsyncRequests: 5, // 按需加载的最大并行请求数 maxInitialRequests: 3, // 一个入口最大并行请求数 automaticNameDelimiter: &apos;~&apos;, // 文件名的连接符 name: true, cacheGroups: &#123; // 缓存组 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125;&#125; 缓存组：缓存组因该是SplitChunksPlugin中最有趣的功能了。在默认设置中，会将 node_mudules 文件夹中的模块打包进一个叫 vendors的bundle中，所有引用超过两次的模块分配到 default bundle 中。更可以通过 priority 来设置优先级。 chunks：chunks属性用来选择分割哪些代码块，可选值有：’all’（所有代码块），’async’（按需加载的代码块），’initial’（初始化代码块）。 3. 在项目中添加SplitChunksPlugin为了方便演示，我们先安装两个类库： lodash 和 axios， 1npm i lodash axios -S 修改 main.js，引入 lodash 和axios 并调用相应方法： 12345678910111213141516171819import Modal from &apos;./components/modal/modal&apos;import &apos;./assets/style/common.less&apos;import _ from &apos;lodash&apos;import axios from &apos;axios&apos;const App = function () &#123; let div = document.createElement(&apos;div&apos;) div.setAttribute(&apos;id&apos;, &apos;app&apos;) document.body.appendChild(div) let dom = document.getElementById(&apos;app&apos;) let modal = new Modal() dom.innerHTML = modal.template(&#123; title: &apos;标题&apos;, content: &apos;内容&apos;, footer: &apos;底部&apos; &#125;)&#125;const app = new App()console.log(_.camelCase(&apos;Foo Bar&apos;))axios.get(&apos;aaa&apos;) 使用SplitChunksPlugin不需要安装任何依赖，只需在 webpack.config.js 中的 config对象添加 optimization 属性： 123456789101112131415optimization: &#123; splitChunks: &#123; chunks: &apos;initial&apos;, automaticNameDelimiter: &apos;.&apos;, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: 1 &#125; &#125; &#125;, runtimeChunk: &#123; name: entrypoint =&gt; `manifest.$&#123;entrypoint.name&#125;` &#125; &#125; 配置 runtimeChunk 会给每个入口添加一个只包含runtime的额外的代码块，name 的值也可以是字符串，不过这样就会给每个入口添加相同的 runtime，配置为函数时，返回当前的entry对象，即可分入口设置不同的runtime。 我们再安装一个 webpack-bundle-analyzer，这个插件会清晰的展示出打包后的各个bundle所依赖的模块： 1npm i webpack-bundle-analyzer -D 引入： 1const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin 使用，在plugins数组中添加即可： 1new BundleAnalyzerPlugin() 打包之后： ​ ​ 各个模块依赖清晰可见，打开 dist/index.html可见我们的代码顺利运行： ​ 以上就是SplitChunksPlugin的基本用法，更多高级的配置大家可以继续钻研（比如多入口应用）。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（五）：处理项目中的资源文件（二）","slug":"webpack4系列教程（五）：处理项目中的资源文件（二）","date":"2019-02-02T13:23:03.000Z","updated":"2019-02-02T13:23:32.012Z","comments":true,"path":"posts/ff9651be.html","link":"","permalink":"http://aventador.top/posts/ff9651be.html","excerpt":"","text":"1. 在项目中使用 less在 src/assets/ 下新建 common.less ： 1234body&#123; background: #fafafa; padding: 20px;&#125; 在 main.js 中引入 common.less ： 1import &apos;./assets/style/common.less&apos; 安装 less-loader： 1npm i less-loader -D 添加 rules： 12345678&#123; test: /\\.less$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos; ] &#125; 打包之后，在浏览器打开 dist/index.html，less文件中的样式已经通过 style 标签载入了： ​ 2. 使用MiniCssExtractPlugin我们之前的样式代码都是通过 style 标签载入的，那么如何通过 link 引入CSS文件的方式实现呢？ 这就需要使用一个插件，在webpack3中通常使用ExtractTextWebpackPlugin，但是在webpack4中已经不再支持ExtractTextWebpackPlugin的正式版，而测试版本又不够稳定，因此我们使用MiniCssExtractPlugin替代。首先安装： 1npm install --save-dev mini-css-extract-plugin 在webpack.config.js 中引入并添加 plugins ： 1const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;) 123new MiniCssExtractPlugin(&#123; filename: &quot;[name].css&quot; &#125;), 修改 CSS 和 less 的 rules： 123456789101112131415161718192021&#123; test: /.css$/, use: [ // &apos;style-loader&apos;, &#123; loader: MiniCssExtractPlugin.loader &#125;, &apos;css-loader&apos; ] &#125;, &#123; test: /.less$/, use: [ // &apos;style-loader&apos;, &#123; loader: MiniCssExtractPlugin.loader &#125;, &apos;css-loader&apos;, &apos;less-loader&apos; ] &#125; npm run build 之后，可见head中引入了一个 main.css 文件： ​ 也正是我们在 common.less 和 modal.css 中的代码 ​ 3. postcss-loaderpostcss-loader 可以帮助我们处理CSS，如自动添加浏览器前缀。 1npm i -D postcss-loader autoprefixer 在根目录下创建 postcss.config.js： 123456789const autoprefixer = require(&apos;autoprefixer&apos;)module.exports = &#123; plugins: [ autoprefixer(&#123; browsers: [&apos;last 5 version&apos;] &#125;) ]&#125; 修改 css 和 less 的 rules： 1234567891011121314151617181920212223&#123; test: /\\.css$/, use: [ // &apos;style-loader&apos;, &#123; loader: MiniCssExtractPlugin.loader &#125;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 1 &#125; &#125;, &apos;postcss-loader&apos; ] &#125;, &#123; test: /\\.less$/, use: [ // &apos;style-loader&apos;, &#123; loader: MiniCssExtractPlugin.loader &#125;, &apos;css-loader&apos;, &apos;postcss-loader&apos;, &apos;less-loader&apos; ] &#125; 在 modal.css中加入： 123.flex&#123; display: flex;&#125; 打包之后打开 main.css，可见浏览器前缀已经加上了： ​","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（四）：处理项目中的资源文件（一）","slug":"webpack4系列教程（四）：处理项目中的资源文件（一）","date":"2019-02-02T13:22:17.000Z","updated":"2019-02-02T13:22:45.809Z","comments":true,"path":"posts/35a01c57.html","link":"","permalink":"http://aventador.top/posts/35a01c57.html","excerpt":"","text":"1. Loader的使用之前的博文已经介绍了Loader的概念以及用法，webpack 可以使用 loader 来预处理文件，这允许你打包除 JavaScript 之外的任何静态资源， 甚至允许你直接在 JavaScript 模块中 import CSS文件。 在 src 目录下新建 components 文件夹，新建 modal 组件： ​ 编写代码： 12345678910111213&lt;!--modal.ejs--&gt;&lt;div class=&quot;modal-parent&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;h3 class=&quot;modal-title&quot;&gt;&lt;%= title %&gt;&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;%= content %&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;%= footer %&gt; &lt;/div&gt;&lt;/div&gt; 123456789// modal.jsimport template from &apos;./modal.ejs&apos;export default function modal () &#123; return &#123; name: &apos;modal&apos;, template: template &#125;&#125; 修改 main.js： 12345678910111213141516import Modal from &apos;./components/modal/modal&apos;const App = function () &#123; let div = document.createElement(&apos;div&apos;) div.setAttribute(&apos;id&apos;, &apos;app&apos;) document.body.appendChild(div) let dom = document.getElementById(&apos;app&apos;) let modal = new Modal() dom.innerHTML = modal.template(&#123; title: &apos;标题&apos;, content: &apos;内容&apos;, footer: &apos;底部&apos; &#125;)&#125;const app = new App() 此时执行 npm run build 会报错 ： ​ webpack 无法解析 .ejs 文件，因此我们需要安装对应的 loader： 1npm i ejs-loader -D 并修改 webpack.config.js 添加 module 属性： 12345678module: &#123; rules: [ &#123; test: /.ejs$/, use: [&apos;ejs-loader&apos;] &#125; ] &#125; 再次执行 npm run build 就不会报错了，打开 dist/index.html ： ​ ​ 可以看到我们的 modal 组件已经成功渲染出来了。 2. 处理项目中的CSS文件在 modal.css 中加入样式代码： 123456789101112131415161718192021.modal-parent&#123; width: 500px; height: auto; border: 1px solid #ddd; border-radius: 10px;&#125;.modal-title&#123; font-size: 20px; text-align: center; padding: 10px; margin: 0;&#125;.modal-body&#123; border: 1px solid #ddd; border-left: 0; border-right: 0; padding: 10px;&#125;.modal-footer&#123; padding: 10px;&#125; 安装 css-loader 和 style-loader： 1npm i css-loader style-loader -D 修改webpack.config.js 中的 module.rules ，添加css-loader 和 style-loader： 123456789101112131415module: &#123; rules: [ &#123; test: /.ejs$/, use: [&apos;ejs-loader&apos;] &#125;, &#123; test: /.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125;, 在 modal.js 中引入 modal.css： 1import &apos;./modal.css&apos; 再次执行 npm run build ，打开 dist/index.html： ​ CSS样式已经通过 style 标签添加到页面上了； ​ 3. 处理项目中的图片在src目录下创建 assets/img ，放入两张图片 ​ 给 modal 添加一个背景图的样式： 123456789.modal-body&#123; border: 1px solid #ddd; border-left: 0; border-right: 0; padding: 10px; background: url(&quot;../../assets/img/bg.jpg&quot;); color: #fff; height: 500px;&#125; 由于webpack无法处理图片资源，所以也要安装对应的 loader 1npm install --save-dev url-loader file-loader 在 webpack.config.js 中添加 loader 1234567891011121314151617rules: [ &#123; test: /.ejs$/, use: [&apos;ejs-loader&apos;] &#125;, &#123; test: /.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;, &#123; test: /.(jpg|jpeg|png|gif|svg)$/, use: &apos;url-loader&apos; &#125; ] 打包代码之后，在浏览器打开 dist/index.html ，可见图片已经显示出来了： ​ 仔细查看这张图片可以发现，它是通过 DataURL 加载出来的： ​ 下面更改 url-loader 的配置，limit表示在文件大小低于指定值时，返回一个DataURL 123456789101112&#123; test: /.(jpg|jpeg|png|gif|svg)$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; name: &apos;[name]-[hash:5].[ext]&apos;, limit: 1024 &#125; &#125; ] &#125; 再次打包后，图片会以文件形式展示出来： ​","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（三）：自动生成项目中的HTML文件","slug":"webpack4系列教程（三）：自动生成项目中的HTML文件","date":"2019-02-02T13:20:44.000Z","updated":"2019-02-02T13:21:15.049Z","comments":true,"path":"posts/6ead29be.html","link":"","permalink":"http://aventador.top/posts/6ead29be.html","excerpt":"","text":"1. webpack中的CommonJS和ES Mudule 规范1.1 CommonJs规范CommonJs规范的出发点：JS没有模块系统、标准库较少、缺乏包管理工具；为了让JS可以在任何地方运行，以达到Java、PHP这些后台语言具备开发大型应用的能力。 在CommonJs规范中： 一个文件就是一个模块，拥有单独的作用域； 普通方式定义的变量、函数、对象都属于该模块内； 通过require来加载模块； 通过exports和modul.exports来暴露模块中的内容； 1.2 ES Mudule 规范ES6在语言标准的层面上，实现了模块功能，基本特点如下： 每一个模块只加载一次， 每一个JS只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取； 每一个模块内声明的变量都是局部变量， 不会污染全局作用域； 模块内部的变量或者函数可以通过export导出； 一个模块可以导入别的模块； 模块功能主要由两个命令构成：export和import；export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能： 12345678910// esm.jslet firstName = &apos;Jack&apos;;let lastName = &apos;Wang&apos;;export &#123;firstName, lastName&#125;// export命令除了输出变量，还可以输出函数export function (a, b) &#123; return a + b&#125; 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块，import命令接受一对大括号，里面指定要从其他模块导入的变量名，大括号里面的变量名，必须与被导入模块对外接口的名称相同。 123456// main.jsimport &#123;firstName, lastName&#125; from &apos;./esm&apos;;function say() &#123; console.log(&apos;Hello , &apos; + firstName + &apos; &apos; + lastName)&#125; 1.3 使用现在，在src目录下新建 sum.js 和 minus.js 12345// sum.js ES Mudule 规范// export default命令，为模块指定默认输出export default function (a, b) &#123; return a + b&#125; 12345// minus.js commonJS 规范module.exports = function (a, b) &#123; return a - b&#125; 修改 main.js 12345import sum from &apos;./sum&apos;import minus from &apos;./minus&apos;console.log(&apos;sum(1, 2): &apos; + sum(1, 2))console.log(&apos;minus(5, 2): &apos; + minus(5, 2)) 执行 npm run build 之后，打开 index.html，在控制台中可以看到输出的结果。 ​ 2. 自动生成项目中的HTML文件在前文中我们为了演示打包好的 main.bundle.js ，在根目录下创建了一个 index.html ，并引入main.bundle.js。而在实际项目中，我们可以通过 webpack 的一个插件：HtmlWebpackPlugin 来自动生成HTML文件并引入我们打包好的JS和CSS文件。 安装：1npm install --save-dev html-webpack-plugin 整理项目目录： 在根目录创建config文件夹，把webpack.config.js移入config，并修改webpack.config.js： 123456789101112131415161718192021222324const path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const config = &#123; mode: &apos;none&apos;, entry: &#123; main: path.join(__dirname, &apos;../src/main.js&apos;) &#125;, output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.join(__dirname, &apos;../dist&apos;) &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &apos;../index.html&apos;), inject: true, minify: &#123; removeComments: true &#125; &#125;) ]&#125;module.exports = config template：模版文件的路径，这里使用根目录下的index.html文件； inject：设为 true 表示把JS文件注入到body结尾，CSS文件注入到head中； minify：removeComments: true 表示删除模版文件中的注释，minify还有很多配置可选请自行参阅； 下一步注释掉index.html 中我们手动引入的 script ： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- &lt;script src=&quot;dist/main.bundle.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 执行 npm run build ，可以看到，dist 目录下多了一个 index.html，这就是通过 HtmlWebpackPlugin 生成的文件，打开dist/index.html，已经自动引入了 main.bundle.js并且注释已被删除。 ​ 至此，我们已经成功实现自动生成项目中的HTML文件了。 3. 清理/dist文件夹每次执行npm run build 打包时，都会有上次的代码遗留下来，导致我们的 /dist 文件夹相当杂乱。通常，在每次构建前清理 /dist 文件夹，是比较推荐的做法。 clean-webpack-plugin 是一个比较普及的管理插件，让我们安装和配置下： 1npm install clean-webpack-plugin --save-dev 在webpack.config.js 中使用： 1const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;) 在 plugins 中加入： 1new CleanWebpackPlugin([&apos;dist&apos;],&#123;root: path.join(__dirname, &apos;../&apos;)&#125;) 第一个参数表示文件夹路径数组；第二个参数是 options 配置项，root 为到webpack根文件夹的绝对路径，默认为 __dirname，由于dist文件夹和webpack.config.js不再相同目录下，因此我们需要重新定义 root 路径，以免无法找到 dist 文件夹。 执行 npm run build ，在命令行中可见： ​ dist 文件夹已被删除了。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（二）：创建项目，打包第一个JS文件","slug":"webpack4系列教程（二）：创建项目，打包第一个JS文件","date":"2019-02-02T13:19:38.000Z","updated":"2019-02-02T13:20:21.894Z","comments":true,"path":"posts/31e86db9.html","link":"","permalink":"http://aventador.top/posts/31e86db9.html","excerpt":"","text":"1. 创建项目1.1 初始化一个项目首先安装nodejs，打开 nodeJs官网 直接下载安装即可，安装完毕后打开命令行工具，进入你的项目文件夹，执行 npm init 进行项目的初始化： 过程中会让你填写项目名、版本、描述、仓库地址、关键字等信息，可以不填一路回车，执行完毕后会在根目录下创建一个 package.json 文件，这样就初始化结束了。 1.2 安装webpack由于在webpack4中已经不再默认安装 webpacl-cli，所以我们要手动安装，在命令行执行 npm i webpack webpack-cli -D 即可。对于大多数项目，建议本地安装。这可以使我们在引入破坏式变更(breaking change)的依赖时，更容易分别升级项目。 2. 打包第一个JS文件首先，我们在根目录下创建一个 webpack.config.js 文件和一个src文件夹。然后在src中创建一个 main.js 文件，如下： 在 main.js 中写一行 1alert('hello world') 然后打开 webpack.config.js ，进行webpack的配置： 1234567891011121314const path = require('path')let config = &#123; mode: 'none', entry: &#123; main: path.join(__dirname, './src/main.js') &#125;, output: &#123; filename: '[name].bundle.js', path: path.join(__dirname, './dist') &#125;&#125;module.exports = config 我们设置了一个名为 main 的入口，并以 src 下的 main.js 作为入口文件，然后输出到根目录下的 dist 文件夹中。 在webpack4中，我们需要设置 mode 属性，用来决定当前是development还是production环境，webpack会根据此值来进行一些默认操作，两种环境的不同配置后面的博文会详解，这里我们设置为 ‘none’ ，来避免默认操作。前文已经说过，path 是 nodeJs中的核心模块用来操作路径，__dirname 表示文件的当前路径（此时为根路径）。而 output中的filename属性，[name] 表示入口的名称，此处就是 main。 接下来打开 package.json 文件，来编写一条命令执行webpack的打包。在 script 中添加： 1\"build\": \"webpack --config webpack.config.js --progress --colors\" webpack –config path/to/your/file/file.js 表示执行某个配置文件，–progress可以让我们看到打包的进度 ， –colors 开启命令行颜色显示，更多的webpack命令参数大家可以另行查阅。 然后就可以在命令行执行：npm run build，执行完毕后，我们可以看到，在根目录下多了一个 dist 文件夹 并有一个 main.bundle.js文件，这就是webpack为我们打包出来的静态资源，而文件路径就是我们在 output 中设置的值。 为了演示打包好的 main.bundle.js ，我们在根目录下创建一个 index.html ，并引入main.bundle.js 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"dist/main.bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在浏览器中打开 index.html，可见main.js中的代码已经被执行了： 在IDE中打开main.bundle.js，代码的最底部可以看到我们在main.js中写的代码。 至此，我们的第一次 webpack 打包就成功了。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]},{"title":"webpack4系列教程（一）：初识webpack","slug":"webpack4系列教程（一）：初识webpack","date":"2019-02-02T13:12:55.000Z","updated":"2019-02-02T13:18:32.287Z","comments":true,"path":"posts/c982193d.html","link":"","permalink":"http://aventador.top/posts/c982193d.html","excerpt":"","text":"1. 什么是webpack先来看看官网对webpack的介绍 ： 本质上，webpack是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。 简单来说webpack就是一个JavaScript的打包器，将各种模块（module）打包成资源文件；还可以通过 Code Spliting 来把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件；webpack 可以使用 loader 来预处理文件，这允许你打包除了JavaScript 之外的任何静态资源。 官网首页很清晰的展示了webpack的主要功能： ​ 我们可以看到，一堆 modules 经过 webpack 打包处理成了各种静态资源。这就是 webpack 2. webpack核心概念在开始学习 webpack 之前，你需要了解 webpack 的四个核心概念： 入口（entry） 出口（output） loader 插件（plugins） 2.1 入口（entry）入口指示 webpack 应该使用哪个模块，来开始构建其内部依赖。进入入口后，webpack 会找出有哪些模块和库是与入口相依赖的。 我们可以在webpack配置中配置entry属性，来设置一个或多个入口起点。以下是一个简单的entry配置：123456const config = &#123; entry: &#123; main: 'path/to/your/entry/index.js' &#125;&#125;module.exports = config 2.2 出口（output） 设置output是为了告诉webpack要在哪里输出其创建的bundle，并且可以对bundle命名。示例： 1234567891011const path = require('path')const config = &#123; entry: &#123; main: 'path/to/your/entry/index.js' &#125;， output: &#123; filename:'[name].bundle.js', path: path.join(__dirname,'./dist') &#125;&#125;module.exports = config 我们通过 output.filename 来设置输出bundle的文件名， output.path 来设置 bundle 的输出路径 path 是 nodeJs 中的核心模块，用来处理项目中的路径。 2.3 loader由于 webpack 只认识 JavaScript 代码，因此就需要借助其他方法来处理那些非 JavaScript 文件，如 css、image、font等。而 loader 可以将所有类型的文件处理成 webpack 能够识别的有效模块，然后再对其进行处理。 loader 中有两个重要属性： test属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件，通常是一个正则表达式； use属性，表示进行转换时，应该使用哪个 loader；123456789101112131415161718192021const path = require('path') const config = &#123; entry: &#123; main: 'path/to/your/entry/index.js' &#125;, output: &#123; filename: '[name].bundle.js', path: path.join(__dirname, './dist') &#125;, module: &#123; loaders: [ &#123; test: /\\.ejs$/, use: ['ejs-loader'] &#125; ] &#125;&#125; module.exports = config 以上示例中loader的配置相当于告诉webpack在遇到 .ejs 的文件时，在打包之前先用 ejs-loader 装换一下。 2.4 插件（plugins）loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。想要使用一个插件，你只需要require()它，然后把它添加到plugins数组中。多数插件可以通过选项(option)自定义。12345678910111213141516171819202122232425262728const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin') // 通过 npm 安装 const config = &#123; entry: &#123; main: 'path/to/your/entry/index.js' &#125;, output: &#123; filename: '[name].bundle.js', path: path.join(__dirname, './dist') &#125;, module: &#123; loaders: [ &#123; test: /\\.ejs$/, use: ['ejs-loader'] &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; title: 'webpack demo', template: path.join(__dirname, './index.html') &#125;) ]&#125; module.exports = config HtmlWebpackPlugin 将为你生成一个 HTML5 文件， 其中包括使用script标签的 body 中的所有 webpack 包，webpack 提供提供了许多功能强大的插件，查阅插件列表获取更多插件的使用方法。","categories":[{"name":"技术文章","slug":"技术文章","permalink":"http://aventador.top/categories/技术文章/"},{"name":"webpack","slug":"技术文章/webpack","permalink":"http://aventador.top/categories/技术文章/webpack/"}],"tags":[]}]}